# atmu — Project Context

## Purpose

`atmu` is a Node.js CLI application built with Pastel + Ink (React for terminals). The repository started from
`create-pastel-app` and currently implements a minimal “Hello, <name>” command, serving as a baseline for adding
more CLI commands.

## Tech Stack

- Runtime: Node.js >= 20, ESM (`"type": "module"`)
- CLI framework / UI: Pastel, Ink, React
- Input validation: Zod (CLI option schemas)
- Tooling: TypeScript (`tsc`), Prettier, XO (eslint), AVA + `ink-testing-library`
- Console styling: Chalk (primarily used in tests)

## Repository Layout

- `src/cli.tsx`: Pastel entry point (`dist/cli.js` is the published `bin`).
- `src/commands/*.tsx`: Ink-based command modules.
- `dist/`: compiled output (generated by `tsc`, gitignored).
- `test.js`: AVA tests (asserts rendered Ink output; imports from `dist/`).

## Project Conventions

### Command Modules

Commands live in `src/commands/<name>.tsx` and typically:

- Export `options`: a `zod` schema defining flags/options (use `.default()` and `.describe()` for help output).
- Export a default React component that receives `{options}` typed via `zod.infer<typeof options>`.
- Keep rendering pure (avoid side effects in React render paths; extract non-UI logic into plain functions).

### Code Style

- Indentation: tabs; line endings: LF; always end files with a newline (`.editorconfig`, `.gitattributes`).
- Formatting: Prettier using `@vdemedes/prettier-config` (`npx prettier --write .`).
- Linting: XO with `xo-react` (Prettier-integrated; see `package.json`).

### Testing Strategy

- `npm test` runs: Prettier checks → XO lint → `npm run build` → AVA.
- Tests render Ink components via `ink-testing-library` and assert the final frame output.
- Tests import from `dist/` (build first), not from `src/`.

### Git Workflow

- Use Conventional Commits going forward (e.g. `feat: ...`, `fix: ...`).
- Never commit generated `dist/` artifacts; modify `src/` and rely on `npm run build`.
- Keep `package-lock.json` in sync with `package.json`.

## Domain Context (CLI)

- The primary user-facing surface is terminal output and CLI flags.
- Treat output text, colors, and help strings as part of the contract.

## OpenSpec Mapping

- Prefer one capability per CLI command.
- Unless there’s a better user-facing name, use the command filename under `src/commands/` as the capability id.
- Specs should focus on observable behavior: flags/options, output, exit codes, and error messages.

## Important Constraints

- Keep changes focused and small; avoid new dependencies unless required.
- For user-facing changes, ensure `npm test` passes.

## External Dependencies

No external services or production APIs are currently required.
