# atmu — Project Context

## Purpose

`atmu` is an interactive Node.js CLI application built with Pastel + Ink (React for terminals). Its MVP focuses on
guiding users through an interactive UI, while future capabilities will automate environment setup and configuration
for downstream tools (for example, Codex CLI).

## Tech Stack

- Runtime: Node.js >= 20, ESM (`"type": "module"`)
- CLI framework / UI: Pastel, Ink, React
- Input validation: Zod (CLI option schemas)
- Tooling: TypeScript (`tsc`), Prettier, XO (eslint), AVA + `ink-testing-library`
- Console styling: Chalk (primarily used in tests)

## Repository Layout

- `src/atmu.tsx`: Pastel entry point (`dist/atmu.js` is the published `bin`).
- `src/commands/*.tsx`: Pastel routes (composition and wiring).
- `src/ui/`: Ink UI (presentation layer).
- `src/utils/`: small generic helpers.
- `src/types/`: shared TypeScript types (cross-layer).
- `dist/`: compiled output (generated by `tsc`, gitignored).
- `test/`: AVA tests (imports from `dist/`).

## Project Conventions

### Layering and Responsibilities

Prefer a layered architecture so UI remains a thin presenter:

- `ui/` renders and handles user interaction (no IO).
- `app/` orchestrates use-cases (state machines, retry/timeout policies, mapping errors to UI-friendly output).
- `domain/` holds pure types and rules (no IO).
- `services/` defines ports (interfaces) for external side effects (fs, npm, OS paths, clock).
- `infra/` implements ports (file IO, process spawning, path resolution).

Not every folder needs to exist from day one; introduce layers when there is real complexity.

### Command Modules

Commands live in `src/commands/<name>.tsx` and typically:

- Export `options`: a `zod` schema defining flags/options (use `.default()` and `.describe()` for help output).
- Export a default React component that receives `{options}` typed via `zod.infer<typeof options>`.
- Keep rendering pure (avoid side effects in React render paths). Route components should call into `app/` use-cases
  and render UI state.

### UI Modules

Treat `src/ui/` as presentation-only. Prefer an internal structure like:

- `src/ui/screens/`: page-level components (used directly by `src/commands/`).
- `src/ui/components/`: reusable UI components.
- `src/ui/layout/`: reusable layout containers and primitives.
- `src/ui/theme/`: design tokens (spacing/borders/colors).

### Code Style

- Indentation: tabs; line endings: LF; always end files with a newline (`.editorconfig`, `.gitattributes`).
- Formatting: Prettier using `@vdemedes/prettier-config` (`npx prettier --write .`).
- Linting: XO with `xo-react` (Prettier-integrated; see `package.json`).

### Testing Strategy

- `npm test` runs: Prettier checks → XO lint → `npm run build` → AVA.
- Tests render Ink components via `ink-testing-library` and assert the final frame output.
- Tests import from `dist/` (build first), not from `src/`.
- End-to-end tests should prefer running the built entry point (`node dist/atmu.js`) in a controlled environment
  (disable colors and interactive input) and assert stable output.

Recommended test layout:

- `test/unit/`: pure logic (domain/app) with stubs for ports.
- `test/ui/`: Ink UI rendering tests (screens/components).
- `test/e2e/`: process-level CLI tests (exit codes, help/version, non-interactive flows).
- `test/helpers/`: shared helpers (CLI runner, temp HOME, env defaults).

### TypeScript + ESM Imports

This project is ESM-first (`"type": "module"`). When importing internal modules from TypeScript, prefer `.js`
specifiers (for example, `import {x} from './x.js'`). TypeScript will map them to `.ts/.tsx` sources during
type-checking, while Node resolves them correctly at runtime in the compiled output.

### Git Workflow

- Use Conventional Commits going forward (e.g. `feat: ...`, `fix: ...`).
- Never commit generated `dist/` artifacts; modify `src/` and rely on `npm run build`.
- Keep `package-lock.json` in sync with `package.json`.

## Domain Context (CLI)

- The primary user-facing surface is terminal output and CLI flags.
- Treat output text, colors, and help strings as part of the contract.

## OpenSpec Mapping

- Prefer one capability per CLI command.
- Unless there’s a better user-facing name, use the command filename under `src/commands/` as the capability id.
- Specs should focus on observable behavior: flags/options, output, exit codes, and error messages.

## Important Constraints

- Keep changes focused and small; avoid new dependencies unless required.
- For user-facing changes, ensure `npm test` passes.

## External Dependencies

No external services or production APIs are currently required.
